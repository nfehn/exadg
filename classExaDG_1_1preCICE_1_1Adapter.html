<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ExaDG: ExaDG::preCICE::Adapter&lt; dim, data_dim, VectorType, VectorizedArrayType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">ExaDG
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceExaDG.html">ExaDG</a></li><li class="navelem"><b>preCICE</b></li><li class="navelem"><a class="el" href="classExaDG_1_1preCICE_1_1Adapter.html">Adapter</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="classExaDG_1_1preCICE_1_1Adapter-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">ExaDG::preCICE::Adapter&lt; dim, data_dim, VectorType, VectorizedArrayType &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="precice__adapter_8h_source.html">precice_adapter.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a917e6a7ae9fc10eed293448892b6ae32" id="r_a917e6a7ae9fc10eed293448892b6ae32"><td class="memItemLeft" align="right" valign="top"><a id="a917e6a7ae9fc10eed293448892b6ae32" name="a917e6a7ae9fc10eed293448892b6ae32"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>value_type</b> = typename <a class="el" href="classExaDG_1_1preCICE_1_1CouplingBase.html">CouplingBase</a>&lt; dim, data_dim, VectorizedArrayType &gt;::value_type</td></tr>
<tr class="separator:a917e6a7ae9fc10eed293448892b6ae32"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a63c8979bce9695ea240c6e01b89e75d4" id="r_a63c8979bce9695ea240c6e01b89e75d4"><td class="memTemplParams" colspan="2">template&lt;typename ParameterClass &gt; </td></tr>
<tr class="memitem:a63c8979bce9695ea240c6e01b89e75d4"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classExaDG_1_1preCICE_1_1Adapter.html#a63c8979bce9695ea240c6e01b89e75d4">Adapter</a> (ParameterClass const &amp;parameters, MPI_Comm mpi_comm)</td></tr>
<tr class="memdesc:a63c8979bce9695ea240c6e01b89e75d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor, which sets up the precice Solverinterface.  <br /></td></tr>
<tr class="separator:a63c8979bce9695ea240c6e01b89e75d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a354da3e6f864bb6f65a03d1b20305bd6" id="r_a354da3e6f864bb6f65a03d1b20305bd6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classExaDG_1_1preCICE_1_1Adapter.html#a354da3e6f864bb6f65a03d1b20305bd6">initialize_precice</a> (VectorType const &amp;dealii_to_precice)</td></tr>
<tr class="memdesc:a354da3e6f864bb6f65a03d1b20305bd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes preCICE and passes all relevant data to preCICE.  <br /></td></tr>
<tr class="separator:a354da3e6f864bb6f65a03d1b20305bd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa13f80f7803b6fc0e07b2555ab802e2a" id="r_aa13f80f7803b6fc0e07b2555ab802e2a"><td class="memItemLeft" align="right" valign="top"><a id="aa13f80f7803b6fc0e07b2555ab802e2a" name="aa13f80f7803b6fc0e07b2555ab802e2a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>add_write_surface</b> (dealii::types::boundary_id const surface_id, std::string const &amp;mesh_name, std::vector&lt; std::string &gt; const &amp;write_data_names, WriteDataType const write_data_type, dealii::MatrixFree&lt; dim, double, VectorizedArrayType &gt; const &amp;data, unsigned int const dof_index, unsigned int const write_quad_index)</td></tr>
<tr class="separator:aa13f80f7803b6fc0e07b2555ab802e2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d1328c3141d81fc8884ba9c14d930f5" id="r_a2d1328c3141d81fc8884ba9c14d930f5"><td class="memItemLeft" align="right" valign="top"><a id="a2d1328c3141d81fc8884ba9c14d930f5" name="a2d1328c3141d81fc8884ba9c14d930f5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>add_read_surface</b> (dealii::MatrixFree&lt; dim, double, VectorizedArrayType &gt; const &amp;data, std::shared_ptr&lt; <a class="el" href="classExaDG_1_1ContainerInterfaceData.html">ContainerInterfaceData</a>&lt; rank, dim, double &gt; &gt; interface_data, std::string const &amp;mesh_name, std::vector&lt; std::string &gt; const &amp;read_data_name)</td></tr>
<tr class="separator:a2d1328c3141d81fc8884ba9c14d930f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbe8ebd71c3d1452576121eae1f02e3e" id="r_adbe8ebd71c3d1452576121eae1f02e3e"><td class="memItemLeft" align="right" valign="top"><a id="adbe8ebd71c3d1452576121eae1f02e3e" name="adbe8ebd71c3d1452576121eae1f02e3e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>advance</b> (double const computed_timestep_length)</td></tr>
<tr class="memdesc:adbe8ebd71c3d1452576121eae1f02e3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Advances preCICE after every timestep. <br /></td></tr>
<tr class="separator:adbe8ebd71c3d1452576121eae1f02e3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a4afd77dd457397b831862cce372cde" id="r_a7a4afd77dd457397b831862cce372cde"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classExaDG_1_1preCICE_1_1Adapter.html#a7a4afd77dd457397b831862cce372cde">save_current_state_if_required</a> (std::function&lt; void()&gt; const &amp;save_state)</td></tr>
<tr class="memdesc:a7a4afd77dd457397b831862cce372cde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saves current state of time dependent variables in case of an implicit coupling.  <br /></td></tr>
<tr class="separator:a7a4afd77dd457397b831862cce372cde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ce4e88f107c66747490f6747705f4d7" id="r_a0ce4e88f107c66747490f6747705f4d7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classExaDG_1_1preCICE_1_1Adapter.html#a0ce4e88f107c66747490f6747705f4d7">reload_old_state_if_required</a> (std::function&lt; void()&gt; const &amp;reload_old_state)</td></tr>
<tr class="memdesc:a0ce4e88f107c66747490f6747705f4d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reloads the previously stored variables in case of an implicit coupling. The current implementation supports subcycling, i.e. previously refers o the last time <code><a class="el" href="classExaDG_1_1preCICE_1_1Adapter.html#a7a4afd77dd457397b831862cce372cde" title="Saves current state of time dependent variables in case of an implicit coupling.">save_current_state_if_required()</a></code> has been called.  <br /></td></tr>
<tr class="separator:a0ce4e88f107c66747490f6747705f4d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d3783b7158738861f8f6e4f54c62c8a" id="r_a1d3783b7158738861f8f6e4f54c62c8a"><td class="memItemLeft" align="right" valign="top"><a id="a1d3783b7158738861f8f6e4f54c62c8a" name="a1d3783b7158738861f8f6e4f54c62c8a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>write_data</b> (std::string const &amp;write_mesh_name, std::string const &amp;write_data_name, VectorType const &amp;write_data, double const computed_timestep_length)</td></tr>
<tr class="separator:a1d3783b7158738861f8f6e4f54c62c8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae60a865405e152e4892513f5e69b4430" id="r_ae60a865405e152e4892513f5e69b4430"><td class="memItemLeft" align="right" valign="top"><a id="ae60a865405e152e4892513f5e69b4430" name="ae60a865405e152e4892513f5e69b4430"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>read_block_data</b> (std::string const &amp;mesh_name, const std::string &amp;data_name) const</td></tr>
<tr class="separator:ae60a865405e152e4892513f5e69b4430"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd75a0a0d95f49c6a44ecfff5e72497b" id="r_acd75a0a0d95f49c6a44ecfff5e72497b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classExaDG_1_1preCICE_1_1Adapter.html#acd75a0a0d95f49c6a44ecfff5e72497b">is_coupling_ongoing</a> () const</td></tr>
<tr class="memdesc:acd75a0a0d95f49c6a44ecfff5e72497b"><td class="mdescLeft">&#160;</td><td class="mdescRight">is_coupling_ongoing Calls the preCICE API function isCouplingOnGoing  <br /></td></tr>
<tr class="separator:acd75a0a0d95f49c6a44ecfff5e72497b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2409b1817f17d6c7754664d3cd073c6" id="r_af2409b1817f17d6c7754664d3cd073c6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classExaDG_1_1preCICE_1_1Adapter.html#af2409b1817f17d6c7754664d3cd073c6">is_time_window_complete</a> () const</td></tr>
<tr class="memdesc:af2409b1817f17d6c7754664d3cd073c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">is_time_window_complete Calls the preCICE API function isTimeWindowComplete  <br /></td></tr>
<tr class="separator:af2409b1817f17d6c7754664d3cd073c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a392e13e5f1240c772d1694a20f7bc982" id="r_a392e13e5f1240c772d1694a20f7bc982"><td class="memItemLeft" align="right" valign="top"><a id="a392e13e5f1240c772d1694a20f7bc982" name="a392e13e5f1240c772d1694a20f7bc982"></a>
static unsigned int const&#160;</td><td class="memItemRight" valign="bottom"><b>rank</b> = n_components_to_rank&lt;data_dim, dim&gt;()</td></tr>
<tr class="separator:a392e13e5f1240c772d1694a20f7bc982"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;int dim, int data_dim, typename VectorType, typename VectorizedArrayType = dealii::VectorizedArray&lt;double&gt;&gt;<br />
class ExaDG::preCICE::Adapter&lt; dim, data_dim, VectorType, VectorizedArrayType &gt;</div><p>The <a class="el" href="classExaDG_1_1preCICE_1_1Adapter.html">Adapter</a> class keeps together with the CouplingInterfaes all functionalities to couple deal.II to other solvers with preCICE i.e. data structures are set up, necessary information is passed to preCICE etc. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a63c8979bce9695ea240c6e01b89e75d4" name="a63c8979bce9695ea240c6e01b89e75d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63c8979bce9695ea240c6e01b89e75d4">&#9670;&#160;</a></span>Adapter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int data_dim, typename VectorType , typename VectorizedArrayType &gt; </div>
<div class="memtemplate">
template&lt;typename ParameterClass &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classExaDG_1_1preCICE_1_1Adapter.html">ExaDG::preCICE::Adapter</a>&lt; dim, data_dim, VectorType, VectorizedArrayType &gt;::Adapter </td>
          <td>(</td>
          <td class="paramtype">ParameterClass const &amp;&#160;</td>
          <td class="paramname"><em>parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Comm&#160;</td>
          <td class="paramname"><em>mpi_comm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor, which sets up the precice Solverinterface. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">data_dim</td><td>Dimension of the coupling data. Equivalent to n_components in the deal.II documentation</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">parameters</td><td>Parameter class, which hold the data specified in the parameters.prm file </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dealii_boundary_surface_id</td><td>Boundary ID of the triangulation, which is associated with the coupling surface. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>The applied matrix-free object </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dof_index</td><td>Index of the relevant dof_handler in the corresponding MatrixFree object </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">read_quad_index</td><td>Index of the quadrature formula in the corresponding MatrixFree object which should be used for data reading </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">is_dirichlet</td><td>Boolean to distinguish between Dirichlet type solver (using the DoFs for data reading) and Neumann type solver (using quadrature points for reading) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a354da3e6f864bb6f65a03d1b20305bd6" name="a354da3e6f864bb6f65a03d1b20305bd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a354da3e6f864bb6f65a03d1b20305bd6">&#9670;&#160;</a></span>initialize_precice()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int data_dim, typename VectorType , typename VectorizedArrayType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classExaDG_1_1preCICE_1_1Adapter.html">ExaDG::preCICE::Adapter</a>&lt; dim, data_dim, VectorType, VectorizedArrayType &gt;::initialize_precice </td>
          <td>(</td>
          <td class="paramtype">VectorType const &amp;&#160;</td>
          <td class="paramname"><em>dealii_to_precice</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes preCICE and passes all relevant data to preCICE. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dealii_to_precice</td><td>Data, which should be given to preCICE and exchanged with other participants. Wether this data is required already in the beginning depends on your individual configuration and preCICE determines it automatically. In many cases, this data will just represent your initial condition. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acd75a0a0d95f49c6a44ecfff5e72497b" name="acd75a0a0d95f49c6a44ecfff5e72497b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd75a0a0d95f49c6a44ecfff5e72497b">&#9670;&#160;</a></span>is_coupling_ongoing()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int data_dim, typename VectorType , typename VectorizedArrayType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classExaDG_1_1preCICE_1_1Adapter.html">ExaDG::preCICE::Adapter</a>&lt; dim, data_dim, VectorType, VectorizedArrayType &gt;::is_coupling_ongoing </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>is_coupling_ongoing Calls the preCICE API function isCouplingOnGoing </p>
<dl class="section return"><dt>Returns</dt><dd>returns true if the coupling has not yet been finished </dd></dl>

</div>
</div>
<a id="af2409b1817f17d6c7754664d3cd073c6" name="af2409b1817f17d6c7754664d3cd073c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2409b1817f17d6c7754664d3cd073c6">&#9670;&#160;</a></span>is_time_window_complete()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int data_dim, typename VectorType , typename VectorizedArrayType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classExaDG_1_1preCICE_1_1Adapter.html">ExaDG::preCICE::Adapter</a>&lt; dim, data_dim, VectorType, VectorizedArrayType &gt;::is_time_window_complete </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>is_time_window_complete Calls the preCICE API function isTimeWindowComplete </p>
<dl class="section return"><dt>Returns</dt><dd>returns true if the coupling time window has been completed in the current iteration </dd></dl>

</div>
</div>
<a id="a0ce4e88f107c66747490f6747705f4d7" name="a0ce4e88f107c66747490f6747705f4d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ce4e88f107c66747490f6747705f4d7">&#9670;&#160;</a></span>reload_old_state_if_required()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int data_dim, typename VectorType , typename VectorizedArrayType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classExaDG_1_1preCICE_1_1Adapter.html">ExaDG::preCICE::Adapter</a>&lt; dim, data_dim, VectorType, VectorizedArrayType &gt;::reload_old_state_if_required </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void()&gt; const &amp;&#160;</td>
          <td class="paramname"><em>reload_old_state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reloads the previously stored variables in case of an implicit coupling. The current implementation supports subcycling, i.e. previously refers o the last time <code><a class="el" href="classExaDG_1_1preCICE_1_1Adapter.html#a7a4afd77dd457397b831862cce372cde" title="Saves current state of time dependent variables in case of an implicit coupling.">save_current_state_if_required()</a></code> has been called. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">state_variables</td><td>Vector containing all variables to reload as reference</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function only makes sense, if the state variables have been stored by calling <code>save_current_state_if_required</code>. Therefore, the order, in which the variables are passed into the vector must be the same for both functions. </dd></dl>

</div>
</div>
<a id="a7a4afd77dd457397b831862cce372cde" name="a7a4afd77dd457397b831862cce372cde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a4afd77dd457397b831862cce372cde">&#9670;&#160;</a></span>save_current_state_if_required()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int data_dim, typename VectorType , typename VectorizedArrayType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classExaDG_1_1preCICE_1_1Adapter.html">ExaDG::preCICE::Adapter</a>&lt; dim, data_dim, VectorType, VectorizedArrayType &gt;::save_current_state_if_required </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void()&gt; const &amp;&#160;</td>
          <td class="paramname"><em>save_state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Saves current state of time dependent variables in case of an implicit coupling. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">state_variables</td><td>Vector containing all variables to store as reference</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function only makes sense, if it is used with <code>reload_old_state_if_required</code>. Therefore, the order, in which the variables are passed into the vector must be the same for both functions. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/exadg/fluid_structure_interaction/precice/<a class="el" href="precice__adapter_8h_source.html">precice_adapter.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
